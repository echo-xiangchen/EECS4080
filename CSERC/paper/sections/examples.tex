

% No more than 3 pages

\subsection{Example: Propositional \& Predicate Logic}

% show one without quantification
\subsubsection{De Morgan's Laws}
{\bf Input File:}
\lstinputlisting[language=Eiffel]{code/De_Morgan_Laws_input.txt}
{\bf Output Result-Part 1:}
\lstinputlisting{code/De_Morgan_Laws_output-1.txt}
\hspace{4mm}{\bf Part 1:} This part indicates that the original De Morgan's Laws are tautologies. \\\\
{\bf Output Result-Part 2:}
\lstinputlisting{code/De_Morgan_Laws_output-2.txt}
\hspace{4mm}{\bf Part 2:} This part indicates that the revised formula is not tautology (i.e., one which holds under all circumstances). The output also shows a counterexample containing the variable type and their values. Here it means when boolean variable $p$ is \emph{false} and boolean variable $q$ is \emph{true}, this formula will be evaluated to \emph{false}. Therefore it is not a tautology.
% show one with quantification (forall)
\subsubsection{Quantification: Single forall ($\forall$)}
~\\For quantification verification, there is no need to declare variables separately.
{\bf Input File:}
\lstinputlisting[language=Eiffel]{code/single_forall_input.txt}
{\bf Output Result:}
\lstinputlisting{code/single_forall_output.txt}
\hspace{4mm}Similarly, this output indicates that the first formula is a tautology, where the second formula is not a tautology with an counterexample that when the value of integer variable $j$ is $1$, this formula will be evaluated to \emph{false}. \\


% show one with quantification (exists)
\subsubsection{Quantification: Single exists ($\exists$)}
~\\
{\bf Input File:}
\lstinputlisting[language=Eiffel]{code/single_exists_input.txt}
{\bf Output Result:}
\lstinputlisting{code/single_exists_output.txt}
\hspace{4mm}In this example, counterexample is not available because z3 SMT Solver is used as the backend tool for \emph{Verifier}, and when the formula contains quantifications, z3 may not provide accurate counterexamples.

\hspace{1mm}Previous example that only contains single forall ($\forall$) could be easily transformed into normal proposition (e.g., $\forall i | i \leq i * i$ is logically equivalent to $i \leq i * i$), therefore \emph{Verifier} could correctly provide the counterexample. \\



% show one with nested quantification (forall/exists, without counterexamples)
\subsubsection{Quantification: Nested quantification ($\forall$ / $\exists$)}
~\\
{\bf Input File:}
\lstinputlisting[language=Eiffel]{code/nested_quantification_input.txt}
{\bf Output Result:}
\lstinputlisting{code/nested_quantification_output.txt}
\hspace{4mm}Similarly, for the formula that contains nested quantification, counterexample may not be available as well.


\subsection{Example: Program Verification}
\hspace{4mm}For verifying programs, \emph{Verifier} supports the input of assignments, alternations, sequential compositions, and loops.\\
% show one example for command (compute tax)
\subsubsection{Compute Tax}
~\\
{\bf Input File:}
\lstinputlisting[language=Eiffel]{code/compute_tax_input.txt}
{\bf Output Result-Part 1:}
\lstinputlisting{code/compute_tax_output-1.txt}
\hspace{4mm}{\bf Part 1:} In the beginning of the output is the original program details, and the program specifications such as precondition(Q), postcondition(R), as well as the implementations(S) will be displayed separately (the original program details and implementations are omitted because they are the same as input file).\\\\
{\bf Output Result-Part 2:}
\lstinputlisting{code/compute_tax_output-2.txt}
\hspace{4mm}{\bf Part 2:} Following part 1, this part will output the \emph{weakest precondition (wp)}. Note that \emph{Verifier} will require user to provide tags for each contract in precondition and postcondition, and calculate the \emph{wp} separately for each postcondition. 

\emph{wp(S, discharged)} is the \emph{weakest precondition} for implementations(S) to establish the postcondition with tag \emph{discharged}, and same as \emph{wp(S, not\_discharged)}.\\\\
{\bf Output Result-Part 3:}
\lstinputlisting{code/compute_tax_output-3.txt}
\hspace{4mm}{\bf Part 3:} This part will show the proof obligation for program correctness using Hoare Logic by generating the boolean predicate  \emph{precondition(Q) $\Rightarrow$ wp} for each postcondition, and indicate if the result is \emph{Discharged} (i.e., the boolean predicate could be proved true), or \emph{Not discharged} with an counterexample.

The separation of proof obligation could help to differentiate the \emph{wp} if there exists multiple postconditions.\\\\

% indices_of(a: ARRAY[INTEGER]; value: INTEGER): ARRAY[INTEGER] -- show complete postcondition  (query)
\subsubsection{Loop: indices\_of}
~\\
\hspace{4mm}For programs that contain loop, there are five conditions that needs to be proved, which will be illustrated in the following example.\\\\
{\bf Input File:}
\lstinputlisting[language=Eiffel]{code/indices_of_input.txt}
{\bf Output Result-Part 1:}
\lstinputlisting{code/indices_of_output-1.txt}
\hspace{4mm}{\bf Part 1:} Similarly, in this part, the original program details and implementations are omitted.\\\\
{\bf Output Result-Part 2:}
\lstinputlisting{code/indices_of_output-2.txt}
\hspace{4mm}{\bf Part 2:} For programs that contain loop, there are five correctness conditions. Therefore, in this part, the result will include the description of these five conditions along with the calculated boolean predicate \emph{precondition(Q) $\Rightarrow$ wp} for each condition.\\\\
{\bf Output Result-Part 3:}
\lstinputlisting{code/indices_of_output-3.txt}
\hspace{4mm}{\bf Part 3:} At the end, the result will indicate if these five conditions are discharged separately.

